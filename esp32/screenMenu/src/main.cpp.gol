#include <Arduino.h>

#define REG_LED_GPIO 33

//Custom pin definitions (override defaults in User_Setup.h)
#define USER_SETUP_LOADED
#define ILI9341_DRIVER  
#define TFT_MISO 12
#define TFT_MOSI 13
#define TFT_SCLK 14
#define TFT_CS   15
#define TFT_DC    2
#define TFT_RST  16

#define LOAD_GLCD
#define LOAD_FONT2
#define LOAD_FONT4
#define LOAD_FONT6
#define LOAD_GFXFF
#define SMOOTH_FONT

#define SPI_FREQUENCY  27000000
#define SPI_READ_FREQUENCY  20000000
#define SPI_TOUCH_FREQUENCY  2500000

#include <TFT_eSPI.h>

TFT_eSPI tft { TFT_eSPI() };

// Maximum number of generations until the screen is refreshed
#define MAX_GEN_COUNT 1000

// The ESP8266 has plenty of memory so we can create a large array
constexpr int cell_size {2};
constexpr int grid_size_x {TFT_WIDTH / cell_size};
constexpr int grid_size_y {TFT_HEIGHT / cell_size};

#define GEN_DELAY 10 // Set a delay between each generation to slow things down

//Current grid and newgrid arrays are needed
uint8_t grid[grid_size_y * grid_size_x];

//The new grid for the next generation
uint8_t newgrid[grid_size_y * grid_size_x];

// forward declaration:
void update_grid_display(void);
void init_grid(void);
void compute_game_of_life();
int neighbors_count(int x, int y);
int id_from_pos(int x, int y);

void setup()   {
  //Set up the display
  tft.init();
  tft.setRotation(0);

  pinMode(REG_LED_GPIO, OUTPUT);
  // Blink the RED LED to show the program has started
  for (int i {0}; i < 20; ++i) {
    digitalWrite(REG_LED_GPIO, LOW);
    delay(100);
    digitalWrite(REG_LED_GPIO, HIGH);
    delay(100);
  }
}

void loop() {

  //Display a simple splash screen
  tft.fillScreen(TFT_BLACK);
  tft.setTextSize(2);
  tft.setTextColor(TFT_WHITE);
  tft.setCursor(40, 5);
  tft.println(F("Arduino"));
  tft.setCursor(35, 25);
  tft.println(F("Cellular"));
  tft.setCursor(35, 45);
  tft.println(F("Automata"));

  delay(1000);

  tft.fillScreen(TFT_BLACK);

  init_grid();

  update_grid_display();

  //Compute generations
  for (int gen = 0; gen < MAX_GEN_COUNT; gen++)
  {
    compute_game_of_life();
    update_grid_display();
    delay(GEN_DELAY);

    std::copy(std::begin(newgrid), std::end(newgrid), std::begin(grid));
  }
}

//Draws the grid on the display
void update_grid_display(void) {
  for (int16_t x {0}; x < grid_size_x; ++x) {
    for (int16_t y {0}; y < grid_size_y; ++y) {
      // Only update the display if the cell has changed
      if (grid[id_from_pos(x,y)] != newgrid[id_from_pos(x,y)]) {
        const uint32_t color { newgrid[id_from_pos(x,y)] ? TFT_WHITE : TFT_BLACK};
        tft.fillRect(cell_size * x, cell_size * y, cell_size, cell_size, color);
      }
    }
  }
}

void init_grid(void) {
  for (int16_t x {0}; x < grid_size_x; ++x) {
    for (int16_t y {0}; y < grid_size_y; ++y) {
      newgrid[id_from_pos(x,y)] = 0;
      bool const pos_on_border { x == 0 || x == grid_size_x - 1 || y == 0 || y == grid_size_y - 1 };
      grid[id_from_pos(x,y)] = pos_on_border ? 0 : random(2);
    }
  }
}

void compute_game_of_life() {
  for (int16_t x = 1; x < grid_size_x; x++) {
    for (int16_t y = 1; y < grid_size_y; y++) {
      const int neighbors { neighbors_count(x, y) };
      if (grid[id_from_pos(x,y)] == 1 && (neighbors == 2 || neighbors == 3 ))
      {
        newgrid[id_from_pos(x,y)] = 1;
      }
      else if (grid[id_from_pos(x,y)] == 1) {
        newgrid[id_from_pos(x,y)] = 0;
      }

      if (grid[id_from_pos(x,y)] == 0 && (neighbors == 3))
      {
        newgrid[id_from_pos(x,y)] = 1;
      }
      else if (grid[id_from_pos(x,y)] == 0) {
        newgrid[id_from_pos(x,y)] = 0;
      }
    }
  }
}

// Check the Moore neighborhood
int neighbors_count(int x, int y) {
  return grid[id_from_pos(x - 1,y)] + grid[id_from_pos(x - 1,y - 1)] + grid[id_from_pos(x,y - 1)] + grid[id_from_pos(x + 1,y - 1)] + grid[id_from_pos(x + 1,y)] + grid[id_from_pos(x + 1,y + 1)] + grid[id_from_pos(x,y + 1)] + grid[id_from_pos(x - 1,y + 1)];
}

int id_from_pos(int x, int y)
{
  return x + y * grid_size_x;
}
